# Pre-processing of bulk RNA-seq data {#Preprocessing}
In this chapter, we will introduce how we align RNA-seq data, check the data quality, quantify gene expression and handle batch effects across samples.    

## Read Mapping
### STAR
<a href="https://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html">STAR</a> is one of the most common tools used for bulk RNA-seq data alignment to generate transcriptome BAM or genomic BAM output, which can be downloaded at <a href="https://github.com/alexdobin/STAR"> here</a>. A tutorial for STAR is available <a href="https://hbctraining.github.io/Intro-to-rnaseq-hpc-O2/lessons/03_alignment.html">here</a>. 

When using STAR, the first step is to create genome index. In our RIMA pipeline, we download the human genome (hg38) STAR index from <a href="https://gdc.cancer.gov/">Genomic Data Commons (GDC) </a>. 

RIMA runs STAR using the following command structure:
```{r eval=FALSE}
      STAR --runThreadN 4 --genomeDir /path/to/index
        --outReadsUnmapped None 
        --chimSegmentMin 12  #generate Chimeric and circulate alignment
        --outSAMunmapped Within 
        --outSAMtype BAM SortedByCoordinate
        --readFilesIn sample_1.fastq.gz sample_2.fastq.gz
        --readFilesCommand zcat
        --outFileNamePrefix sample
        --quantMode TranscriptomeSAM GeneCounts # generate outputs in transcript coordinates and mapped read counts per gene
```

This generates outputs such as the following:
```{r eval=FALSE}
sampleAligned.sortedByCoord.out.bam
sampleAligned.toTranscriptome.out.bam 
sampleReadsPerGene.out.tab
sampleChimeric.out.junction 
sampleLog.final.out
```

RIMA uses samtools to generate statistics from the alignment BAM file (sampleAligned.sortedByCoord.out.bam):
```{r eval=FALSE}
samtools stats sampleAligned.sortedByCoord.out.bam | grep ^SN | cut -f 2- > sample.sorted.bam.stat.txt
```

The resulting file (sample.sorted.bam.stat.txt) provides the following information:
```{r eval=FALSE}
raw total sequences:	60589702
filtered sequences:	0
sequences:	60589702
is sorted:	1
1st fragments:	30294851
last fragments:	30294851
reads mapped:	59963698
reads mapped and paired:	59963698	# paired-end technology bit set + both mates mapped
reads unmapped:	626004
reads properly paired:	59963698	# proper-pair bit set
reads paired:	60589702	# paired-end technology bit set
reads duplicated:	0	# PCR or optical duplicate bit set
reads MQ0:	110872	# mapped and MQ=0
reads QC failed:	0
non-primary alignments:	3102614
total length:	6058970200	# ignores clipping
total first fragment length:	3029485100	# ignores clipping
total last fragment length:	3029485100	# ignores clipping
bases mapped:	5996369800	# ignores clipping
bases mapped (cigar):	5952761135	# more accurate
bases trimmed:	0
bases duplicated:	0
mismatches:	0	# from NM fields
error rate:	0.000000e+00	# mismatches / bases mapped (cigar)
average length:	100
average first fragment length:	100
average last fragment length:	100
maximum length:	100
maximum first fragment length:	100
maximum last fragment length:	100
average quality:	39.7
insert size average:	971.3
insert size standard deviation:	1899.5
inward oriented pairs:	29281286
outward oriented pairs:	700563
pairs with other orientation:	0
pairs on different chromosomes:	0
```

## Quality Control
RseQC is a standard tool for checking the quality of reads alignment, providing the principal measurements of RNA-seq data quality. An RseQC tutorial is available <a href="http://rseqc.sourceforge.net/">here</a>. \

To reduce running time, we first create a subset of the BAM files to be used by RseQC to assess alignment quality.  The subset BAM files are a set of housekeeping genes.
.
```{r eval=FALSE}
## Example of subsampling 50% of input alignment
samtools view -s 0.5 -b sampleAligned.sortedByCoord.out.bam  > sample_downsampling.bam 
# Extract the alignment of housekeeping gene.
bedtools intersect -a sample_downsampling.bam -b housekeeping_refseqGenes.bed > sample_downsampling_housekeeping.bam 
# index BAM
samtools index sample_downsampling_housekeeping.bam > sample_downsampling_housekeeping.bam.bai 
```

### Quality metrics

1. <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-016-0922-z#Sec2">Transcript integrity number (TIN)</a> is the most widely used measure of RNA integrity, which is the percentage of transcripts that have uniform read coverage across the genome. RseQC calculates the TIN of each transcript and reports mean TIN, median TIN and standard deviation for all transcripts in a sample. The <a href="http://rseqc.sourceforge.net/#tin-py">median TIN score (medTIN) </a> across all transcripts is commonly used to indicate the RNA integrity of each sample. \
2. <a href="http://rseqc.sourceforge.net/#read-distribution-py">Read distribution </a> summarizes the fraction of reads aligned into different genomic regions, such as exon and intron regions. \
3. <a href="http://rseqc.sourceforge.net/#genebody-coverage-py">Gene body coverage</a> shows the RNA-seq read coverage over the gene body. \
4. <a href="http://rseqc.sourceforge.net/#junction-saturation-py">Junction saturation</a> is used to determine if sequencing depth is sufficient to perform alternative splicing analysis. \

Low quality samples have low alignment fractions, low integrity (median TIN) and/or abnormal read distributions and should be removed in downstream analysis. \

## Gene quantification
After the alignment of sequencing reads and quality check, we quantify the gene or transcript expression from the BAM files.Both <a href="https://combine-lab.github.io/salmon/getting_started/">Salmon</a> and <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-12-323">RSEM</a> are widely used for gene quantification. Salmon conducts fast transcript-level quantification, and RSEM performs both gene-level and transcript-level quantification. Salmon is usually faster and less memory-consuming than RSEM. Both tools generate transcripts per million (TPM), reads per kilobase of exon model (transcript) per million mapped reads (RPKM) and fragments per kilobase of exon model (transcript) per million mapped reads (FPKM) expression.  All three measures (TPM, RPKM, FPKM) are normalization methods that account for both sequencing depth and gene lengths. (Longer transcripts will have more reads.) TPM is currently thought to be the best method to normalize gene counts.  <a href="https://htseq.readthedocs.io/en/master/tour.html#counting-reads-by-genes">HTSeq </a> and STAR quantify gene expression according to mapped read counts. Both normalized gene expression and read counts can be used for differential expression analysis. \

RIMA runs Salmon with a command similar to the following:
```
salmon quant -t salmon_gdc_index/gencode.v22.ts.fa -l A -a sample.transcriptome.bam -o SRR8281218
```

```
##---Output folder structure---##

SRR8281218
├── SRR8281218.quant.sf
├── SRR8281218.transcriptome.bam.log
├── aux_info
│   ├── ambig_info.tsv
│   ├── expected_bias.gz
│   ├── fld.gz
│   ├── meta_info.json
│   ├── observed_bias.gz
│   └── observed_bias_3p.gz
├── cmd_info.json
├── libParams
└── logs
    └── salmon_quant.log
```   

The following is an example of output from a quant.sf file from Salmon ('SRR8281218.quant.sf'):
```
Name	Length	EffectiveLength	TPM	NumReads
ENST00000456328.2	1657	1474.085	0.000000	0.000
ENST00000450305.2	632	449.595	0.000000	0.000
ENST00000488147.1	1351	1168.085	7.412619	139.959
ENST00000619216.1	68	69.000	0.000000	0.000
ENST00000473358.1	712	529.382	0.000000	0.000
ENST00000469289.1	535	353.431	0.000000	0.000
ENST00000607096.1	138	16.202	0.000000	0.000
```

## Batch effect removal
Batch effects across samples are easily ignored but worth considering for immunotherapy cohort studies. Bacth effects are usually caused by unbalanced experimental design and confound the estimation of group differences. For example, samples processed at different facilities may have sequencing differences that are not due to actual biological differences in the samples themselves.  To avoid confounding actual biology variation with the effects of experimental design, <a href="https://www.degruyter.com/document/doi/10.2202/1544-6115.1027/html"> limma </a> and <a href="https://academic.oup.com/biostatistics/article/8/1/118/252073?login=true">Combat</a> are common approaches to correct batch effects. Limma uses a two-way ANOVA approach.  Combat uses an empirical Bayes approach, which is critical for small batches to avoid over-correction. For large batches, both methods should be similar. The <a href="https://bioconductor.org/packages/release/bioc/html/sva.html">sva</a> R package integrates both methods for batch effect correction.
Principal components analysis (PCA) or unsupervised clustering before and after batch effect removal is an excellent way to validate that a batch effect has been removed. 

To evaluate if your samples have a batch effect, RIMA will generate PCA plots of gene expression data before and after batch effect removal by limma.  To utilize this feature, modify the "batch" parameter in the config.yaml file for your run.  

Example of PCA before and after batch correction using limma.
```{r fig.align='center', echo=FALSE, fig.cap='Before(left) and after(right) batch correction with Limma'}
knitr::include_graphics('images/PCA_synbatch.png', dpi = NA)
```

## Video demo of RIMA
<iframe width="560" height="315" src="https://www.ynutube.com/embed/NEbi-pYNhak" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> \
