[["index.html", "Tutorial of RNA-seq tumor immunity analysis Chapter 1 About this tutorial 1.1 Installation 1.2 Pre-built reference data", " Tutorial of RNA-seq tumor immunity analysis 2021-05-07 Chapter 1 About this tutorial This is a tutorial about integrative computing analysis of tumor immunity using bulk RNA-seq data. We will focus on the inferring the immune infiltration, immune repertoire, immune response and neoantigen prediction from gene expression profile. We developed a RNA-seq immune analysis pipeline named RIMA that is available at https://github.com/liulab-dfci/RIMA/. 1.1 Installation 1.2 Pre-built reference data "],["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction Tumor RNA-seq has become an important technique for molecular profiling and immune characterization of tumors. RNA-seq Immune Analysis performs integrative computational modeling of tumor microenvironment from bulk tumor RNA-seq data, which has the potential to offer essential insights to cancer immunology and immune-oncology studies. Figure 2.1: Flowchat of RIMA pipeline The pre-processing module includes four main procedures: Read mapping Quality control Gene quantification Batch effect removal The downstream analysis includes seven modules: Differential expression analysis Immune infiltration estimation Immune repertoire inference Neoantigen detection Microbiome characterization Immunotherapy response prediction Gene fusion Microbiome "],["Preprocessing.html", "Chapter 3 Pre-processing of bulk RNA-seq data 3.1 Read Mapping 3.2 Quality Control 3.3 Gene quantification 3.4 Batch effect removal 3.5 Video demo of RIMA", " Chapter 3 Pre-processing of bulk RNA-seq data In this chapter, we will introduce how we align RNA-seq data, check the data quality, quantify gene expression and handle batch effects across samples. 3.1 Read Mapping 3.1.1 STAR STAR is one of the most common tools used for bulk RNA-seq data alignment to generate transcriptome BAM or genomic BAM output, which can be downloaded at here. A tutorial of runing STAR is available at here. Once you have installed STAR, the first step is to create genome index. In our RIMA pipeline, we download the human genome (hg38) STAR index from Genomic Data Commons (GDC) . To run STAR of a sample: STAR --runThreadN 4 --genomeDir /path/to/index --outReadsUnmapped None --chimSegmentMin 12 #generate Chimeric and circulate alignment --outSAMunmapped Within --outSAMtype BAM SortedByCoordinate --readFilesIn sample_1.fastq.gz sample_2.fastq.gz --readFilesCommand zcat --outFileNamePrefix sample --quantMode TranscriptomeSAM GeneCounts # generate outputs in transcript coordinates and mapped read counts per gene Example outputs: sampleAligned.sortedByCoord.out.bam sampleAligned.toTranscriptome.out.bam sampleReadsPerGene.out.tab sampleChimeric.out.junction sampleLog.final.out Then we use samtools to generate statistics of alignment BAM file: samtools stats sampleAligned.sortedByCoord.out.bam | grep ^SN | cut -f 2- &gt; sample.sorted.bam.stat.txt Example output of BAM summary: raw total sequences: 60589702 filtered sequences: 0 sequences: 60589702 is sorted: 1 1st fragments: 30294851 last fragments: 30294851 reads mapped: 59963698 reads mapped and paired: 59963698 # paired-end technology bit set + both mates mapped reads unmapped: 626004 reads properly paired: 59963698 # proper-pair bit set reads paired: 60589702 # paired-end technology bit set reads duplicated: 0 # PCR or optical duplicate bit set reads MQ0: 110872 # mapped and MQ=0 reads QC failed: 0 non-primary alignments: 3102614 total length: 6058970200 # ignores clipping total first fragment length: 3029485100 # ignores clipping total last fragment length: 3029485100 # ignores clipping bases mapped: 5996369800 # ignores clipping bases mapped (cigar): 5952761135 # more accurate bases trimmed: 0 bases duplicated: 0 mismatches: 0 # from NM fields error rate: 0.000000e+00 # mismatches / bases mapped (cigar) average length: 100 average first fragment length: 100 average last fragment length: 100 maximum length: 100 maximum first fragment length: 100 maximum last fragment length: 100 average quality: 39.7 insert size average: 971.3 insert size standard deviation: 1899.5 inward oriented pairs: 29281286 outward oriented pairs: 700563 pairs with other orientation: 0 pairs on different chromosomes: 0 3.2 Quality Control RseQC is a standard tool for checking the quality of reads alignment, providing principal measurements of RNA-seq data quality. RseQC tutorial is available at here. To reduce running time, we first subsampled the BAM file and use only housekeeping genes for quality check using RseQC. ## Example of subsampling 50% of input alignment samtools view -s 0.5 -b sampleAligned.sortedByCoord.out.bam &gt; sample_downsampling.bam # Extract the alignment of housekeeping gene. bedtools intersect -a sample_downsampling.bam -b housekeeping_refseqGenes.bed &gt; sample_downsampling_housekeeping.bam # index BAM samtools index sample_downsampling_housekeeping.bam &gt; sample_downsampling_housekeeping.bam.bai 3.2.1 Quality metrics Transcript integrity number (TIN) is the most widely used measure RNA integrity, which is the percentage of transcripts that has uniform read coverage across the genome. RseQC calculated the TIN each transcripts and the median TIN score (medTIN) across all transcripts has is commonly used to indicate the RNA integrity and of each sample. Read distribution summarizes the fraction of reads aligned into different genomic regions, such as exon and intron regions. Gene body coverage shows the RNA-seq read coverage over the gene body. Junction saturation detects the splicing junctions with different resampling percentages of reads to determine if the sequencing depth is sufficient to perform alternative splicing analysis. Samples with low alignment fraction or low integrity or abnormal reads distribution usually have bad quality and should be removed in downstream analysis. 3.3 Gene quantification After the alignment of sequencing reads and quality check, we will quantify the gene or transcript expression from the BAM file.Both Salmon and RSEM are widely used for gene quantification. Salmon conducts fast transcript-level quantification, and RSEM performed both gene-level and transcript-level quantification. Salmon is usually faster and less memory-consuming than RSEM. Both tools generate transcripts per million (TPM), reads per kilobase of exon model per million reads (RPKM) and fragments per kilobase of exon model per million mapped reads (FPKM) expression, which is the normalized gene quantification that removing the effect of different gene length. In addition to TPM, HTSeq and STAR quantify gene expression according to mapped read counts. Both normalized gene expression and read counts can be used for differential expression analysis. 3.4 Batch effect removal Batch effects across samples is easily ignored but worth considering problems for immunotherapy cohort study. It is usually caused by unbalanced experimental design where estimation of group difference, and they are interdependent. To avoid the actual biology variation confounded by batch effect, Limma and Combat are common approaches to correct the batch effects. Limma uses a two-way ANOVA approach, while Combat uses the empirical Bayes approach, which is critical for small batches to avoid over-correction. For large batches, both methods should be similar. The sva R package integrates both methods for batch effect correction. To check whether the batch effect has been removed, principal components analysis (PCA) or unsupervised clustering before and after batch effect removal will be an excellent way to validate. To ensure a solid downstream RNA-seq analysis, it is essential to generate a gene expression profile mitigating the batch effect and group difference from a well-designed study. Example of PCA before and after batch effect of tumor location: Figure 3.1: Before(left) and after(right) batch correction with Limma 3.5 Video demo of RIMA "],["Differential.html", "Chapter 4 Differential gene analysis 4.1 Differential gene expression using DESeq2 4.2 Different gene expression analysis 4.3 Gene set enrichment analysis (GSEA) 4.4 Single sample gene set enrichment analysis (ssGSEA)", " Chapter 4 Differential gene analysis Once you obtain gene counts from the preprocessing modules of RIMA, you can compare gene expression levels for different sample phenotypes. For example, you may wish to know which genes are differentially expressed between patients who respond and do not respond to a particular treatment. In addition, you may wish to know if particular gene sets are enriched in expression between different phenotypes. These gene sets may be associated with a known biological pathway, process or molecular function. The differential gene analysis module of RIMA allows you to perform these comparisons. 4.1 Differential gene expression using DESeq2 The DESeq2 is the most commonly used package that provides methods for comparison of gene expression levels. The package is described in: Love, M.I., Huber, W., Anders, S. (2014) Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15:550. 10.1186/s13059-014-0550-8 Details about how to run DeSeq2 are also included in the DESeq2 vignette. 4.1.1 Inputs of DESeq2 The DESeq2 accepts four kinds of inputs: 1) Transcript abundance; 2) Read count matrix: 3) htseq-count files and 4) A SummarizedExpreriment object. We processed our gene quantification using Salmon in our preprocess module, so we will run DESeq2 using the output in the quant.sf files provided from salmon. The quant.sf files were generated during the preprocessing module. vignette. We first created a tx2gene.csv files that contains transcripts id and gene names as below: ID,GENENAME ENST00000000233.8,ARF5 ENST00000000412.6,M6PR ENST00000000442.9,ESRRA ENST00000001008.5,FKBP4 ENST00000001146.5,CYP26B1 ENST00000002125.7,NDUFAF7 ENST00000002165.9,FUCA2 ENST00000002501.9,DBNDD1 ENST00000002596.5,HS3ST1 Then we uses tximport to import transcripts abundance data from the quant.sf files from salmon as described in the DESeq2: ### filelist are a list of quant.sf files generated by Salmon gene quantification. txi &lt;- tximport(filelist, type=Salmon, tx2gene=tx2gene) 4.2 Different gene expression analysis After loading the transcripts abundance, we are ready to find out differentially expressed gene between your selected condition. We need to be careful when running DESeq2 with batch effects. ### Running DESeq2 without batch effect We will run DESeq2 to determine differential expression for a particular phenotype. In our case, we are interested in the genes differential between responders and non-responders, which is the “Responders” column headings in the metasheet. We uses the information in “designs” for DESeq2 in the following manner: ddsTxi &lt;- DESeqDataSetFromTximport(txi, colData = samples, design = ~ Responder) dds &lt;- DESeq(ddsTxi) 4.2.1 Running DESeq2 with batch effect DESeq2 can account for any batch effect by providing the batch variable as a covariate. If your batch effect analysis from the preprocessing module indicated that there is a batch effect in your samples, set the “batch” field in config.yaml to the appropriate column name in your metasheet. We uses the information in “batch” for DESeq2 in the following manner: ddsTxi &lt;- DESeqDataSetFromTximport(txi, colData = samples, design = ~ syn_batch + Responder) dds &lt;- DESeq(ddsTxi) 4.2.2 Output from DESeq2 Output file of DESeq2 generated values for baseMean, log2FoldChange, lfcSE, stat, pvalue, padj. These fields have the following meaning: baseMean = the average of the normalized counts for all samples Log2FoldChange = log base 2 fold changes for the condition tested. For example if the file is Responder_nonresponder_VS_resonder_DESqe2_raw.txt, Log2FoldChange will be the estimated logarithmic fold change log2(nonresponder/responder). lfcSE = Log2FoldChange Standard Error stat= Wald statistic pvalue = Wald test p value for the Log2FoldChange estimate padj. = FDR adjusted p value (Benjamini-Hochberg adjusted p value) {comparison condition}_DEseq2_raw.txt lists Gene names directly from the DESeq2 output. It also contains a value for -log10(padj). 4.2.3 Volcano Plot(s) Vocalno plot is usually used to visualize the results of differentially expressed genes with x axis represents the logFC and y axis represent the -log10(P.value). Up-regulated genes has positive logFC and down-regulated genes has negative logFC. Below is an example of volcano plot from previous differential results and we labeled the genes with below cutoff: FDR &lt; 0.05 Log2FoldChange &gt; 1 Figure 4.1: Volcano plot 4.3 Gene set enrichment analysis (GSEA) GSEA was developed by UC San Diego and the Broad Institute. It is described in Subramanian, Tamayo, et al. (2005, PNAS 102, 15545-15550) and Mootha, Lindgren, et al. (2003, Nat Genet 34, 267-273). GSEA tools and software can be found on the GSEA website. Gene Set Enrichment Analysis can be used to detect patterns in differential expression that affect particular gene pathways, molecular functions, cellular components or processes. We uses the GSEA software to look for enrichment in the following gene sets: KEGG canonical pathways Gene Ontology sets – including Biological Process (BP), Cellular Component (CC) and Molecular Function (MF). RIMA uses a ranked list of DESeq2 outputs. Ranking is based on the following: sign(data$log2FoldChange) * (-log10(data$pvalue)) GSEA output is reported in 4 text files: {comparison condition_phenotype1_VS_phenotype2}_KEGG_terms.txt {comparison condition_phenotype1_VS_phenotype2}_GO_CC_terms.txt {comparison condition_phenotype1_VS_phenotype2}_GO_BP_terms.txt {comparison condition_phenotype1_VS_phenotype2}_GO_MF_terms.txt Each of these tab separated files contains the following information: ID = ID of the gene set Description = description of the gene set setSize = number of genes in the gene set after filtering out genes not in the expression data. enrichmentScore = the degree to which the gene set is enriched in the top or bottom of the ranked set of genes. NES = normalized gene enrichment score. pvalue = nominal p value p.adjust = family-wise error adjusted p value qvalues = FDR adjusted p value rank = the position in the ranked list at which the maximal enrichment score was achieved. leading_edge = 3 statistics (tags, list and signal) on the subset of genes that most influence the enrichment score core_enrichment group = the subset of genes that contribute most to the enrichment score. significance = a representation of the p.adjust value using stars. One star is set for p.adjust &lt;0.1, two stars &lt;0.5 and three stars &lt; 0.01. Please see the GSEA documentation for more information about these values. 4.4 Single sample gene set enrichment analysis (ssGSEA) ssGSEA is a different method of trying to find enriched pathways in your dataset. GSEA uses the differential expression patterns of all samples to generate enrichment scores based on phenotypic differences. In contrast, ssGSEA generates enrichment scores for each sample. Phenotypic differences can then be used to compare enriched pathways rather than differential genes expression levels. Please see ssGSEA for more information. The input to ssGSEA is the tpm_convertID.batch file generated by LIMMA. The file contains log2 transformed tpm values. config.yaml setting for ssGSEA… output from ssGSEA…. "],["Repertoire.html", "Chapter 5 Immune repertoire 5.1 TRUST4 5.2 BCR cluster calculation 5.3 Clonotypes per kilo-reads (CPK) 5.4 TCR and BCR entropy and Colonality 5.5 Fraction of reads mapped to TCR and BCR 5.6 Somatic hypermutation rate of BCR 5.7 Ig isotype frequency 5.8 Cohort analysis 5.9 Video demo", " Chapter 5 Immune repertoire Once tumors are infiltrated with B cells and T cells, B cells and T cells are potentially activated by BCR and TCR respectively recognizing and binding to tumor-associated antigens. BCR and TCR undergo V(D)J recombination, encoding complementarity-determining region 3 (CDR3) with highly variable peptide sequence binding to the peptide-MHC complex. The V(D)J junctional sequence assembly is a major source of TCR/BCR diversity for recognizing the diverse antigens. Thus, immune repertoire profiling is essential for quantifying B/T cell diversity and clonality, which are essential tumor immune characteristics and key indicators of immunotherapy response. Currently, newly-emerging immune sequencing techniques, such as TCR-seq and BCR-seq, have been designed to sequence B and T cell receptors through quantitative PCR (qPCR). However, the experimental technology is cost-consuming to achieve. To overcome this difficulty, Tcr Receptor Utilities for Solid Tissue (TRUST) has been developed to infer the immune repertoire from bulk RNA-seq reads, via de novo assembled CDR3 sequences that are not aligned to the host genome. It enables users to overview the immune repertoire of tumors, including CDR3 sequence length, the frequency of various V genes, J genes, and VJ pairs for different chains in the TCR and BCR. For cohort analysis, some basic metrics for TCRs and BCRs across samples could be computed to relate immune repertoire characteristics to specific phenotypes, including the fraction of reads mapped to TCR/BCR, the number of TCR/BCR unique clonotypes of CDR3 sequences, TCR/BCR diversity, and the clonality. Since the activated B cells will undergo somatic hyper-mutation, antibody production, and Immunoglobulin (Ig) class switches during B cell maturation, it is necessary to measure the somatic hypermutation (SHM) rate for BCRs. In addition, TRUST predicts Ig isotypes for BCRs, which allows for quantifying the Ig compositions representing different maturation statuses (IGHM, IGHD, IGHG3, IGHG1, IGHA1, IGHG2, IGHG4, IGHA2, IGHE) and generating an Ig class switches network. Taken together, the immune repertoire analysis quantifies the T/B cell population in both individual and cohort levels, enabling to characterize the dynamic evolution in the TME via the diversity and clonal expansion of tumor-infiltrating T cells or B cells. 5.1 TRUST4 Example Command: ./run-trust4 -b example.bam -f hg38_bcrtcr.fa --ref human_IMGT+C.fa The above command utilizes hg3_bcrtcr.fa (fasta file containing the coordinates and sequences of V/D/J/C genes) and human_IMGT+C.fa (V/D/J/C gene reference file from the IMGT database), and produces a simple report (example_report.tsv). This produced report contains a list of assembled clonotypes from example.bam with the following fields: “read_count,frequency(proportion of read_count),CDR3_dna,CDR3_amino_acids,V,D,J,C,consensus_id,consensus_id_full_length”. These fields tell us the abundance, CDR3 sequence (nucleotides and amino acids), gene segment usage, and identifier for each clonotype. 5.1.1 TRUST4 output 5.2 BCR cluster calculation We use one sample for a instance to show how RIMA process the results from TRUST4. We start from a proccessed file that RIMA directly add the sample ID to TRUST4_report.tsv. This step makes it more easier to combine all of individual sample results in following analysis. library(dplyr) #load processed function source(&quot;TRUST4/trust4_metric_functions.R&quot;) # read the individual sample result from RIMA cdr3 &lt;- read.table(file = &quot;TRUST4/SRR8281233_cdr3.out.processed.txt&quot;, sep = &quot;\\t&quot;, header = TRUE, stringsAsFactors = FALSE) #filter out count of cdr ==0 and add the phenotype info for downstream comparison #This SRR8281233 smaple is Non-responder phenotype &lt;- &quot;NR&quot; cdr3 &lt;- subset(cdr3, count &gt; 0) %&gt;% mutate(V = as.character(V), J = as.character(J), C = as.character(C), CDR3aa = as.character(CDR3aa)) %&gt;% mutate(clinic = as.character(phenotype)) head(cdr3) ## count frequency CDR3nt ## 1 125 0.03682734 TGCATGCAAGCTCTACAAACTCCGTACACTTTT ## 2 124 0.03654850 TGTCAGCAGCGTAGCAACTGGCCTTGGACGTTC ## 3 98 0.05410145 TGTGCGATGGGGGATAGTAGTGGCTGGTACCGTCCTCCCGACTCCTGG ## 4 97 0.02847096 TGTCAACATTACGGTACCTCGTGGACGTTC ## 5 79 0.02320237 TGTCAGCAGCGTAGCAACTGGCCGCTCACTTTC ## 6 78 0.02289418 TGCATGCAGCGTGTGAGTCTTCCCCACACTTTT ## CDR3aa V D J C cid ## 1 CMQALQTPYTF IGKV2-28*01 . IGKJ2*01 IGKC assemble0 ## 2 CQQRSNWPWTF IGKV3-11*01 . IGKJ1*01 IGKC assemble1701 ## 3 CAMGDSSGWYRPPDSW IGHV3-33*01 IGHD6-19*01 IGHJ5*01 IGHG1 assemble1 ## 4 CQHYGTSWTF IGKV3-20*01 . IGKJ1*01 IGKC assemble1713 ## 5 CQQRSNWPLTF IGKV3-11*01 . IGKJ4*01 IGKC assemble1717 ## 6 CMQRVSLPHTF IGKV2-40*01 . IGKJ2*01 IGKC assemble1719 ## sample clinic ## 1 SRR8281233 NR ## 2 SRR8281233 NR ## 3 SRR8281233 NR ## 4 SRR8281233 NR ## 5 SRR8281233 NR ## 6 SRR8281233 NR #determine whether the cdr animo acid is complete or partial cdr3$is_complete &lt;- sapply(cdr3$CDR3aa, function(x) ifelse(x != &quot;partial&quot; &amp;&amp; x != &quot;out_of_frame&quot; &amp;&amp; !grepl(&quot;^_&quot;,x) &amp;&amp; !grepl(&quot;^\\\\?&quot;, x),&quot;Y&quot;,&quot;N&quot;)) #exact the TCR and BCR cdr3.bcr &lt;- subset(cdr3, grepl(&quot;^IG&quot;,V) | grepl(&quot;^IG&quot;,J) | grepl(&quot;^IG&quot;,C)) cdr3.tcr &lt;- subset(cdr3, grepl(&quot;^TR&quot;,V) | grepl(&quot;^TR&quot;,J) | grepl(&quot;^TR&quot;,C)) #add lib size and clinic traits cdr3.bcr &lt;- cdr3.bcr %&gt;% mutate(lib.size = sum(count)) cdr3.tcr &lt;- cdr3.tcr %&gt;% mutate(lib.size = sum(count)) #split BCR into heavy chain and light chain cdr3.bcr.heavy &lt;- subset(cdr3.bcr, grepl(&quot;^IGH&quot;,V) | grepl(&quot;^IGH&quot;,J) | grepl(&quot;^IGH&quot;,C)) cdr3.bcr.light &lt;- subset(cdr3.bcr, grepl(&quot;^IG[K|L]&quot;,V) | grepl(&quot;^IG[K|L]&quot;,J) | grepl(&quot;^IG[K|L]&quot;,C)) #save BCR and TCR info for downsteam use outdir &lt;- &quot;TRUST4/individual/&quot; sample &lt;- &quot;SRR8281233&quot; save(cdr3.bcr.light, file = paste(outdir, &quot;TRUST4_BCR_light.Rdata&quot;,sep = &quot;&quot;)) save(cdr3.bcr.heavy, file = paste(outdir, &quot;TRUST4_BCR_heavy.Rdata&quot;,sep = &quot;&quot;)) save(cdr3.tcr, file = paste(outdir, &quot;TRUST4_TCR.Rdata&quot;,sep = &quot;&quot;)) #BCR clustering #Note that not every sample have BCR cluster sample_bcr_cluster &lt;- BuildBCRlineage(sampleID = sample, Bdata = cdr3.bcr.heavy, start=3, end=10) ## use default substitution matrix ## use default substitution matrix ## use default substitution matrix save(sample_bcr_cluster,file = paste(outdir, sample,&quot;_TRUST4_BCR_heavy_cluster.Rdata&quot;, sep = &quot;&quot;)) attributes(sample_bcr_cluster) ## $names ## [1] &quot;RGSPRFID&quot; &quot;KVPGRRTR&quot; &quot;RNLYYGAY&quot; head(sample_bcr_cluster$RGSPRFID) ## $distMat ## [,1] [,2] [,3] [,4] ## [1,] 0 1 1 3 ## [2,] 0 0 2 4 ## [3,] 0 0 0 2 ## [4,] 0 0 0 0 ## ## $Sequences ## [1] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG&quot; ## [2] &quot;TGTGCGCGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG&quot; ## [3] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCTGG&quot; ## [4] &quot;TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCCAG&quot; ## ## $data ## count frequency CDR3nt ## 1 2 0.001099511 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG ## 2 2 0.001099511 TGTGCGCGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCCTTCACTTCTGG ## 3 7 0.003848289 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCTGG ## 4 2 0.001099511 TGTGCGAGAGGATCCCCCCGGTTCATTGACTACGGTGGTTCCTTTCACTTCCAG ## CDR3aa V D J C cid ## 1 CARGSPRFIDYGGSLHFW IGHV4-31*01 IGHD4-23*01 IGHJ4*02 IGHG1 assemble836 ## 2 CARGSPRFIDYGGSLHFW IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## 3 CARGSPRFIDYGGSFHFW IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## 4 CARGSPRFIDYGGSFHFQ IGHV4-31*11 IGHD4-23*01 IGHJ4*02 IGHG1 assemble90 ## sample clinic is_complete lib.size ## 1 SRR8281233 NR Y 5184 ## 2 SRR8281233 NR Y 5184 ## 3 SRR8281233 NR Y 5184 ## 4 SRR8281233 NR Y 5184 5.3 Clonotypes per kilo-reads (CPK) CPK can be calculated by taking the number of unique CDR3 calls for a chain divided by the total number of reads for that chain, with this result being multiplied by 1000. This is used as a measure of clonotype diversity. #TCR CPK cpk &lt;- aggregate(CDR3aa ~ sample+clinic+lib.size, cdr3.tcr, function(x) length(unique(x))) %&gt;% mutate(CPK = signif(CDR3aa/(lib.size/1000),4)) cpk ## sample clinic lib.size CDR3aa CPK ## 1 SRR8281233 NR 73 20 274 5.4 TCR and BCR entropy and Colonality The Shannon entropy index is a measure used for repertoire diversity using clonotype frequencies, which reflects both richness and evenness of the repertoire. This measure informs us of the probability that two random selections from the same repertoire would represent the same clonotype. Clonality can be measured using normalized entropy over the number of unique clones. It is equivalent to 1 - Pielou’s Evenness, making it inversely proportional to diversity. A higher clonality index indicates an uneven repertoire due to expansion of clones. #BCR clonality and entropy sample &lt;- &quot;SRR8281233&quot; single_sample_bcr_clonality &lt;- getClonality(sample, cdr3.bcr.heavy, start=3, end=10) ## use default substitution matrix ## use default substitution matrix ## use default substitution matrix ## [1] &quot;SRR8281233&quot; single_sample_bcr_clonality[1:3] ## sample clonality entropy ## &quot;SRR8281233&quot; &quot;0.0899083128267854&quot; &quot;6.83997594611138&quot; #TCR clonality and entropy sample &lt;- &quot;SRR8281233&quot; single_sample_tcr_clonality &lt;- getClonalityTCR(sample,cdr3.tcr) single_sample_tcr_clonality ## sample clonality entropy ## &quot;SRR8281233&quot; &quot;0.0699534783052342&quot; &quot;4.0850595412347&quot; 5.5 Fraction of reads mapped to TCR and BCR The fraction of reads mapped to either TCR or BCR is indicated by the V,D,J-gene prefixes of clonotypes. The fraction is composed of the proportion of reads with genes prefixed by “TR” (TCR) and genes prefixed by “IG” (BCR). #exact the mapped reads info from alignment index file sample &lt;- &quot;SRR8281233&quot; file &lt;- read.table(&quot;TRUST4/SRR8281233.sorted.bam.stat.txt&quot;,sep = &quot;\\t&quot;,row.names = 1) mapped.reads &lt;- file[&quot;reads mapped:&quot;,&quot;V2&quot;] individual.stats &lt;- cbind.data.frame(sample = sample, map.reads = mapped.reads) #---------fraction of BCR reads------------------ ##extract library size lib.size &lt;- cdr3.bcr.heavy %&gt;% group_by(sample) %&gt;% dplyr::summarise(lib = mean(lib.size)) ##combine stats and library size bcr.lib.reads &lt;- merge(individual.stats,lib.size,by = &quot;sample&quot;) %&gt;% mutate(Infil = signif(as.numeric(lib)/as.numeric(map.reads),4)) #------------fraction of TCR reads----------------- ##extract library size lib.size &lt;- cdr3.tcr %&gt;% group_by(sample) %&gt;% dplyr::summarise(lib = mean(lib.size)) ##combine stats and library size tcr.lib.reads &lt;- merge(individual.stats,lib.size,by = &quot;sample&quot;) %&gt;% mutate(Infil = signif(as.numeric(lib)/as.numeric(map.reads),4)) combined &lt;- rbind(bcr.lib.reads, tcr.lib.reads) %&gt;% mutate(Type = c(&quot;BCR&quot;, &quot;TCR&quot;)) combined ## sample map.reads lib Infil Type ## 1 SRR8281233 59972094 5184 8.644e-05 BCR ## 2 SRR8281233 59972094 73 1.217e-06 TCR 5.6 Somatic hypermutation rate of BCR A somatic hypermutation (SHM) is a cellular mechanism of the immune system when adapting to new foreign elements and occurs with a point mutation in the variable regions of Ig genes. TRUST4 collapses reads with SHMs into the same contig by representing a contig as the consensus of the assembled reads. The consensus indicates that a specific nucleotide sequence has the highest weight among the assembled reads. SHM.ratio &lt;- getSHMratio(sample_bcr_cluster) ## [1] 54 ## [1] 2 ## [1] 48 ## [1] 3 ## [1] 51 ## [1] 1 5.7 Ig isotype frequency The immunoglobulin heavy (IGH) locus includes the constant heavy (IGHC) gene segment. This gene segment includes different isotypes (IGHA1, IGHA2, IGHD, IGHE, IGHG1, IGHG2, IGHG3, IGHG4, IGHM) and the proportion of the abundance of these different segments indicates the isotype frequency. The isotype frequency can be found by isolating reads with genes prefixed “IGH” and comparing the occurrence of different isotypes in the C_gene column. #This SRR8281233 smaple is Non-responder phenotype &lt;- &quot;NR&quot; st.Ig &lt;- cdr3.bcr.heavy %&gt;% group_by(clinic,sample) %&gt;% mutate(est_clonal_exp_norm = frequency/sum(frequency)) %&gt;% #as.numeric(sample.clones[filename,2]) dplyr::filter(C != &quot;*&quot; &amp; C !=&quot;.&quot;) %&gt;% group_by(sample, C) %&gt;% dplyr::summarise(Num.Ig = sum(est_clonal_exp_norm)) %&gt;% mutate(clinic = phenotype) ## `summarise()` has grouped output by &#39;sample&#39;. You can override using the `.groups` argument. st.Ig ## # A tibble: 8 x 4 ## # Groups: sample [1] ## sample C Num.Ig clinic ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 SRR8281233 IGHA1 0.134 NR ## 2 SRR8281233 IGHA2 0.0682 NR ## 3 SRR8281233 IGHD 0.00385 NR ## 4 SRR8281233 IGHG1 0.542 NR ## 5 SRR8281233 IGHG2 0.0704 NR ## 6 SRR8281233 IGHG3 0.0280 NR ## 7 SRR8281233 IGHG4 0.0126 NR ## 8 SRR8281233 IGHM 0.0407 NR 5.8 Cohort analysis We show the basic immune repertoire-related metrics above using a single sample. Now we combine all of samples in the demo dataset to do some comparison. #load the pre-processed results that contain all samples #These results would be automatically generated after running RIMA immune repertoire module inputdir &lt;- &quot;TRUST4/Cohort/&quot; load(paste(inputdir,&quot;TRUST4_BCR_heavy_cluster.Rdata&quot;, sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_clonality.Rdata&quot;, sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_SHMRatio.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_Ig_CS.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_BCR_heavy.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR_lib_reads_Infil.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR.Rdata&quot;,sep = &quot;&quot;)) load(paste(inputdir,&quot;TRUST4_TCR_clonality.Rdata&quot;,sep = &quot;&quot;)) #call the ploting function source(&quot;TRUST4/trust4_plot.R&quot;) meta &lt;- read.csv(&quot;metasheet.csv&quot;) p &lt;- Trust4_plot(phenotype = &quot;Responder&quot;, metasheet = meta) p 5.9 Video demo "],["Infiltration.html", "Chapter 6 Immune Infiltration 6.1 Cibersort 6.2 TIMER 6.3 quanTIseq 6.4 xCell 6.5 EPIC 6.6 MCP-counter 6.7 Comparison across cell type 6.8 Comparison across sample 6.9 Video demo", " Chapter 6 Immune Infiltration Cell infiltration estimation in the tumor microenvironment TME is a complicated system consisting of tumor cells, immune cells, stromal cells, and extracellular factors. Estimating cell components is essential for classifying the distinct tumor immune microenvironment (TIME) phenotype. Furthermore, dissecting the TIME by evaluating cell components plays a significant role in untangling the mechanism of tumor progression and immune evasion, which is essential for providing a guideline for immunotherapy selection. There are two major approaches for estimating cell infiltration in TME, deconvolution-based and marker-based approaches. The deconvolution-based method infers cell type fractions from the bulk gene expression of a given list of signature genes, such as TIMER, quanTIseq, EPIC, and CIBERSORT. The marker-based approaches to quantify the enrichment score utilizing a list of cell-specific marker genes, such as xCell and MCP-counter. ImmuneDeconv is an R package that integrated these six methods. All six algorithms estimate cell infiltration of immune cells and stromal cells, while EPIC and quanTIseq make it available to assess uncharacterized cells defined as cancer cells. Of note, CIBERSORT absolute mode, EPIC, and quanTIseq support inter-comparison between sample groups and intra-comparison between cell types. And TIMER, xCell, and MCP-counter support only inter-comparison between sample groups for one cell type. Immune cell deconvolution is still an open question in the field, and different algorithms could give slightly different results. Each algorithm estimates one general cell type or specific cell subtype. The best way is to focus on the observations consistently predicted by various algorithms, in which case the gold standard is not available. 6.1 Cibersort CIBERSORT is a deconvolution-based method that uses the v-support vector regression method (v-SVR) to estimate each immune cell type’s relative proportion from gene expression profile (GEP). It requires an input of reference gene expression signatures. CIBERSORT provided a gene signature matrix (LM22.txt) which contains 547 genes distinguish 7 T-cell types, naïve and memory B cells, plasma cell, and NK cells. The CIBERSORT absolute mode scales cellular fraction to a score that reflects each cell type’s absolute proportion, allowing comparison across both samples and cell types. The CIBERSORT source code and LM22 signature matrix are only freely available to academic users, which can be applied through CIBERSORT website . To run CIBERSORT using ImmuneDeconv: #demo suppressMessages(library(immunedeconv)) #read gene expression matrix input &lt;- &quot;tpm_convertID.txt&quot; #load CIBERSORT source code and signiture matrix source(&quot;CIBERSORT.R&quot;) sig_matrix &lt;- &quot;LM22.txt&quot; #Run CIBERSORT abs #The number of permutation cibersort_perm = 100 #Quantile normalization of input mixture, default = FALSE for RNA-Seq data cibersort_qn = FALSE #whether to apply absolute mode in cibersort cibersort_abs = TRUE #sig.score = for each mixture sample, define S as the median expression,level of all genes in the signature matrix divided by the median expression level of all genes in the mixture. Multiple cell subset fractions by S. cibersort_abs_method = &quot;sig.score&quot; res_ciber &lt;- CIBERSORT(sig_matrix, input, perm = cibersort_perm, QN = cibersort_qn, absolute = cibersort_abs, abs_method = cibersort_abs_method) head(res_ciber,3) ## B cells naive B cells memory Plasma cells T cells CD8 ## SRR8281218 0.002023271 0.003060637 0.000000000 0.12297118 ## SRR8281219 0.010693087 0.000000000 0.001201108 0.38499197 ## SRR8281226 0.000000000 0.008281786 0.000000000 0.01442307 ## T cells CD4 naive T cells CD4 memory resting ## SRR8281218 0 0.14975225 ## SRR8281219 0 0.22216858 ## SRR8281226 0 0.08219228 ## T cells CD4 memory activated T cells follicular helper ## SRR8281218 0 0.08924869 ## SRR8281219 0 0.16924345 ## SRR8281226 0 0.06671124 ## T cells regulatory (Tregs) T cells gamma delta NK cells resting ## SRR8281218 0.09617560 0 0.06763887 ## SRR8281219 0.00000000 0 0.00000000 ## SRR8281226 0.04296535 0 0.07211706 ## NK cells activated Monocytes Macrophages M0 Macrophages M1 ## SRR8281218 0.0000000 0.06195550 0.0000000 0.01550602 ## SRR8281219 0.1076938 0.03659288 0.1552708 0.03207925 ## SRR8281226 0.0357515 0.41486727 0.0000000 0.00000000 ## Macrophages M2 Dendritic cells resting Dendritic cells activated ## SRR8281218 0.7049077 0 0.000000000 ## SRR8281219 1.1589577 0 0.000000000 ## SRR8281226 0.6474766 0 0.004669831 ## Mast cells resting Mast cells activated Eosinophils Neutrophils ## SRR8281218 0.11994310 0 0.003766691 0.00000000 ## SRR8281219 0.24218289 0 0.000000000 0.07942792 ## SRR8281226 0.01289667 0 0.002926060 0.12361329 ## P-value Correlation RMSE Absolute score (sig.score) ## SRR8281218 0.06 0.15699314 1.027475 1.436950 ## SRR8281219 0.16 0.05195861 1.072383 2.600503 ## SRR8281226 0.06 0.13503937 1.054532 1.528892 6.2 TIMER TIMER uses linear least square regression to estimate six tumor-infiltrating immune cell types (B, CD4T, CD8T, neutrophils, macrophages, and dendritic cells). Since the tumor purity is very different across different cancer cell types, one of key steps is that TIMER selected the specific genes as immune signatures based on the correlation between gene expression and tumor purity. Tutorial of TIMER: Tutorial of TIMER2: Note that the TIMER score can only be compared within samples, and the current version of TIMER supports 23 different TCGA cancer types. #load gene expression matrix df &lt;- read.table(input, sep = &quot;,&quot;, row.names = 1, header = TRUE, check.names = FALSE) #The TCGA cancer acronyms of demo data cancertype &lt;- &quot;GBM&quot; #Available cancer type immunedeconv::timer_available_cancers res_timer = as.data.frame(deconvolute(df, &quot;timer&quot;,indications=rep(tolower(cancertype),ncol(df)))) 6.3 quanTIseq The quanTIseq uses constrained least square regression to estimate absolute proportions of 10 immune cell types infiltration levels from RNA seq data. Therefore, the score of quanTIseq allows inter- or intra-samples comparison. quanTIseq provides an entire pipeline that can either process the pre-computed gene expression matrix (TPM matrix) or directly analyze bulk RNA-Seq data. #Run quanTIseq res_quant = as.data.frame(deconvolute(df, &quot;quantiseq&quot;)) 6.4 xCell xCell performs single-sample gene set enrichment analysis (ssGSEA) on expression data to evaluate the enrichment of immune marker genes. These marker genes validated using cytometry immunophenotyping and in-silico simulations. Notes that results of xCell depend on the number of samples, the power of estimation might be lower if providing limited non-heterogeneous samples #Run xCell res_xcell = as.data.frame(deconvolute(df, &quot;xcell&quot;)) 6.5 EPIC EPIC uses constrained least square regression to estimate six immune cell types, fibroblasts, and endothelial cells. EPIC collects a unique gene expression reference from circulating and tumor-infiltrating cells. Further, it extended its algorithm to evaluate the uncharacterized cancer cell. The score that comes from the EPIC algorithm is the absolute value that can be compared within or across samples. #Run EPIC res_epic = as.data.frame(deconvolute(df, &quot;epic&quot;)) 6.6 MCP-counter MCP-counter uses its transcriptomic markers (TM) curated from 81 public datasets to estimate fibroblasts, endothelial, and eight immune cell types. The difference of mean log2-expression of marker genes samples is a key to evaluate the immune cell infiltration levels. #Run EPIC res_mcp = as.data.frame(deconvolute(df, &quot;mcp_counter&quot;)) 6.7 Comparison across cell type Using results from CIBERSORT abs mode as an example, we provide another two functions to do inter- or intra comparison. #extract the immune cell score from results of CIBERSORT res_ciber &lt;- res_ciber[,1:22] res_ciber ## B cells naive B cells memory Plasma cells T cells CD8 ## SRR8281218 0.002023271 0.003060637 0.000000000 0.12297118 ## SRR8281219 0.010693087 0.000000000 0.001201108 0.38499197 ## SRR8281226 0.000000000 0.008281786 0.000000000 0.01442307 ## SRR8281236 0.119197082 0.000000000 0.175028807 0.05841897 ## SRR8281230 0.000000000 0.001725996 0.000000000 0.02099308 ## SRR8281233 0.074569126 0.000000000 0.022548328 0.09612605 ## SRR8281244 0.000000000 0.133329588 0.041170411 0.58644201 ## SRR8281245 0.057960600 0.000000000 0.001729094 0.71691961 ## SRR8281243 0.021015715 0.000000000 0.000000000 0.05560813 ## SRR8281251 0.000000000 0.014652173 0.000000000 0.12265135 ## SRR8281238 0.010961877 0.000000000 0.000000000 0.07328546 ## SRR8281250 0.000000000 0.007211828 0.000000000 0.11124637 ## T cells CD4 naive T cells CD4 memory resting ## SRR8281218 0 0.1497522454 ## SRR8281219 0 0.2221685808 ## SRR8281226 0 0.0821922827 ## SRR8281236 0 0.0616983261 ## SRR8281230 0 0.2636255094 ## SRR8281233 0 0.0540161771 ## SRR8281244 0 0.0000000000 ## SRR8281245 0 0.1346463483 ## SRR8281243 0 0.2983063326 ## SRR8281251 0 0.0008469304 ## SRR8281238 0 0.1462044340 ## SRR8281250 0 0.0912421429 ## T cells CD4 memory activated T cells follicular helper ## SRR8281218 0 0.08924869 ## SRR8281219 0 0.16924345 ## SRR8281226 0 0.06671124 ## SRR8281236 0 0.02097714 ## SRR8281230 0 0.04434860 ## SRR8281233 0 0.01702242 ## SRR8281244 0 0.20198021 ## SRR8281245 0 0.08491094 ## SRR8281243 0 0.02547211 ## SRR8281251 0 0.13107578 ## SRR8281238 0 0.06549731 ## SRR8281250 0 0.08310786 ## T cells regulatory (Tregs) T cells gamma delta NK cells resting ## SRR8281218 0.096175601 0 0.06763887 ## SRR8281219 0.000000000 0 0.00000000 ## SRR8281226 0.042965351 0 0.07211706 ## SRR8281236 0.016105425 0 0.01389437 ## SRR8281230 0.003663422 0 0.06303278 ## SRR8281233 0.000000000 0 0.00000000 ## SRR8281244 0.000000000 0 0.00000000 ## SRR8281245 0.064756411 0 0.00000000 ## SRR8281243 0.024209477 0 0.02796011 ## SRR8281251 0.000000000 0 0.03345416 ## SRR8281238 0.000000000 0 0.00000000 ## SRR8281250 0.021319048 0 0.11199972 ## NK cells activated Monocytes Macrophages M0 Macrophages M1 ## SRR8281218 0.00000000 0.0619555028 0.0000000 0.0155060204 ## SRR8281219 0.10769382 0.0365928767 0.1552708 0.0320792458 ## SRR8281226 0.03575150 0.4148672695 0.0000000 0.0000000000 ## SRR8281236 0.01814658 0.0009746492 0.4032181 0.0265143088 ## SRR8281230 0.09185887 0.0765481976 0.0000000 0.0007397341 ## SRR8281233 0.12935356 0.3642042042 0.0000000 0.0146104309 ## SRR8281244 0.20599738 0.0000000000 0.0000000 0.0111442172 ## SRR8281245 0.03120120 0.2150193255 0.0000000 0.2086448744 ## SRR8281243 0.04129983 0.3731328017 0.0000000 0.0712853735 ## SRR8281251 0.01556184 0.1857497242 0.0000000 0.0649557029 ## SRR8281238 0.13490224 0.1832561460 0.0000000 0.0058262672 ## SRR8281250 0.05657334 0.2021661178 0.0000000 0.0026188791 ## Macrophages M2 Dendritic cells resting Dendritic cells activated ## SRR8281218 0.7049077 0.0000000000 0.000000000 ## SRR8281219 1.1589577 0.0000000000 0.000000000 ## SRR8281226 0.6474766 0.0000000000 0.004669831 ## SRR8281236 1.0709844 0.0000000000 0.000000000 ## SRR8281230 0.2730022 0.0005978992 0.000000000 ## SRR8281233 2.1503686 0.0000000000 0.000000000 ## SRR8281244 1.4746127 0.0000000000 0.000000000 ## SRR8281245 1.4430364 0.0000000000 0.000000000 ## SRR8281243 1.0892152 0.0000000000 0.000000000 ## SRR8281251 0.7517625 0.0000000000 0.000000000 ## SRR8281238 0.4755445 0.0004518878 0.000000000 ## SRR8281250 0.4947339 0.0000000000 0.003493596 ## Mast cells resting Mast cells activated Eosinophils Neutrophils ## SRR8281218 0.11994310 0.00000000 0.003766691 0.000000000 ## SRR8281219 0.24218289 0.00000000 0.000000000 0.079427915 ## SRR8281226 0.01289667 0.00000000 0.002926060 0.123613285 ## SRR8281236 0.06937423 0.00000000 0.000000000 0.017959545 ## SRR8281230 0.24554128 0.00000000 0.000000000 0.055268474 ## SRR8281233 0.00000000 0.04839376 0.000000000 0.008407325 ## SRR8281244 0.00000000 0.21527869 0.000000000 0.028385274 ## SRR8281245 0.21885148 0.00000000 0.000000000 0.040372665 ## SRR8281243 0.13542538 0.00000000 0.000000000 0.006578541 ## SRR8281251 0.00000000 0.20693722 0.001084478 0.058856146 ## SRR8281238 0.00000000 0.32409274 0.013953275 0.047135836 ## SRR8281250 0.00000000 0.10459983 0.000000000 0.035923878 #load plotfunction source(&quot;plotfunction.R&quot;) #load metasheet for RIMA pipeline metasheet &lt;- read.csv(&quot;metasheet.csv&quot;) #methods: CIBERSORT, quanTIseq, EPIC, MCP, xCell, TIMER hmap(ta = res_ciber, meta = metasheet, methods = &quot;CIBERSORT&quot;, phenotype = &quot;Responder&quot;) 6.8 Comparison across sample boxfig(ta = res_ciber, meta = meta, methods = &quot;CIBERSORT&quot;, phenotype = &quot;Responder&quot;) 6.9 Video demo "],["Response.html", "Chapter 7 Immune Response 7.1 TIDE 7.2 Microsatelite instability (MSI) 7.3 Response comparison analysis of biomarkers 7.4 Video demo", " Chapter 7 Immune Response Cancer immunotherapy utilizing immune checkpoint blockade (ICB) has gained excellent progression in treating advanced-stage patients. However, only a small fraction of patients achieved a response to the immunotherapy due to the complexity and heterogeneity of the TME. An increasing number of biomarkers have widely been used to estimate the clinical effectiveness of immunotherapy, such as ICB-related gene signatures (PD1, PDL1, CTLA4), tumor-infiltrating lymphocytes, tumor mutation burden, neoantigens, microsatellite instability (MSI), and serum markers. Nevertheless, there is an urgent need to build a method integrating the multiple dynamic factors to characterize TME and predict immunotherapy response. Currently, two major approaches have been effectively utilized in immunotherapy response prediction. One is models constructed using transcriptome expression profiles of immune checkpoint or T-cell activity, and the other one is artificial intelligence-based algorithms using imaging characteristics of lesions. For tumor RNA-seq data, TIDE models tumor immune evasion by combining gene signatures estimating T cell dysfunction and exclusion to predict ICB response, which may provide critical insights to guide clinical treatment. This computational framework computes the TIDE score for tumors and separates them into responders and non-responders. In detail, TIDE provides T cell dysfunction score, T cell exclusion score, cytotoxic T lymphocyte score, and scores of cell types restricting T cell infiltration in TME, including cancer-associated fibroblasts (CAF), myeloid-derived suppressor cells (MDSC), and M2 macrophages. These metrics scores help the biologists understand the TME status or T cell functions of interest. In this case, tumor RNA-seq profiling leverages the power of gene signature expression for quantifying the dynamic TME status, providing guidance of immunotherapy response prediction for clinicians. 7.1 TIDE TIDE is a transcriptome biomarker database of ICB response by modeling tumor immune dysfunction and exclusion. The statistical model of TIDE was trained on clinical tumor profiles without ICB treatments since the immune evasion mechanisms in treatment naïve tumors are also likely to influence patient response to immunotherapies. The TIDE model has been applied to evaluate T cell dysfunction and exclusion signatures across over 33K samples in 188 tumor cohorts from well-curated databases, including TCGA, METABRIC, and PRECOG, as well as our in-house collections. A command line TIDE is available at https://github.com/liulab-dfci/TIDEpy. 7.1.1 Cold and hot tumors TIDE estimate the cytotoxic T Lymphocyte (CTL) level in tumor from the average expression of CD8A, CD8B, GZM, GZMB and PRF1 from treatment naïve tumors. ‘Hot tumors’ have above-average CTL values among all samples, while ‘Cold tumors’ have CTL values below average. TIDE score is the combination of T cell dysfunction estimated from hot tumors and T cell exclusion estimated from cold tumors. 7.1.2 T cell dysfunction For hot tumors with high CTL values, the T cell dysfunction is modeled from Cox-PH repression in TIDE: \\[ Harzard = a*CTL+b*P+d*CTL*P \\] Where the variable CTL represents the CTLs levels, P represents the status of candidate genes and the coefficient d reflects the effect of interaction between CTL and candidate gene P on dealth harzard. The T cell dysfunction score of individual tumor is calcaulted as: \\[ Dysfunction = \\frac{d}{StdErr(d)} \\] 7.1.3 T cell exclusion For hot tumors with high CTL values, TIDE calculates T cell exclusion score to estimate the immune escape. The T cell exlclusion score is the average expression profile from cancer-associated fibroblasts (CAFs), myeloid-derived suppressor cells (MDSCs) and tumor-associated macrophages (TAMs), which are reported to restrict T cell infiltration in tumor. 7.1.4 Normaliztion The input for TIDE is a normalized TPM matrix, the steps for normalization is: Do the log2(TPM+1) transformation. Subtract the average across your samples. 7.1.5 Running TIDE TIDE supports cancer type specific analysis of melanoma and non-small cell lung cancer (NSCLC), our data is from glioblastoma multiforme (GBM), so we set -c as other cancer type and force TIDE to normalized the TPM matrix. To run TIDE: tidepy -o TIDE_score.txt -c Other --force_cormalization tpm_convertID.txt Example outputs of TIDE: tide_res &lt;- read.table(&quot;TIDE_score.txt&quot;,header=TRUE,sep=&#39;\\t&#39;) print(tide_res) ## X No.benefits Responder TIDE IFNG MSI.Score ## 1 SRR8281219 False False 1.6807050 0.05776435 0.9171423549 ## 2 SRR8281236 False False 1.4737267 -0.44182240 0.0891168795 ## 3 SRR8281251 False False 0.3144625 0.72752075 0.9280729250 ## 4 SRR8281233 False True -0.5123185 0.34811417 0.5993703233 ## 5 SRR8281244 False True -0.9853986 0.21431441 0.9799730558 ## 6 SRR8281238 False True -1.9248032 -0.90589129 0.0009766364 ## 7 SRR8281230 True False 1.1296130 -1.26863334 0.2538437260 ## 8 SRR8281245 False False 0.4289897 3.88767936 0.0017826161 ## 9 SRR8281250 False False 0.3857392 -1.24755461 0.9386137813 ## 10 SRR8281226 False False 0.1014286 -1.21158487 0.9948723196 ## 11 SRR8281218 False True -0.6018754 -1.00643540 0.9824508826 ## 12 SRR8281243 False True -0.6690983 0.84652886 0.0098136280 ## CD274 CD8 CTL.flag Dysfunction Exclusion MDSC ## 1 1.614004697 1.0782170 False -0.80734665 1.6807050 0.12475420 ## 2 -0.571334617 -1.9530623 False -0.35635988 1.4737267 0.11729077 ## 3 -0.000579565 -1.3454258 False -0.37740657 0.3144625 0.10977895 ## 4 -0.411058820 -0.6337873 False 0.53196445 -0.5123185 -0.14295622 ## 5 -0.606725356 3.4653282 False 0.08913789 -0.9853986 -0.10578784 ## 6 -0.024306339 -0.6112697 False 0.92111671 -1.9248032 -0.11623220 ## 7 0.770622520 -1.5651339 False -0.37601870 1.1296130 0.09720250 ## 8 1.057713700 5.4054676 True 0.42898972 -0.5965523 -0.04806820 ## 9 -1.316139124 -1.0777690 False -0.23234131 0.3857392 0.05575237 ## 10 -0.867420745 -1.6865379 False -0.80196436 0.1014286 -0.01248780 ## 11 -1.080325919 -0.2808955 False 0.39883468 -0.6018754 -0.05455741 ## 12 1.435549568 -0.7951312 False 0.70257668 -0.6690983 -0.05677437 ## CAF TAM.M2 ## 1 0.15396889 -0.026495315 ## 2 0.07706755 0.026260679 ## 3 -0.08909806 0.018044264 ## 4 0.05095308 0.014947245 ## 5 -0.04049768 -0.009330085 ## 6 -0.14906967 -0.015234391 ## 7 0.06391605 0.003882855 ## 8 0.03353989 -0.073846662 ## 9 -0.03536659 0.035777532 ## 10 0.02156957 0.002648255 ## 11 -0.08670749 0.057716177 ## 12 -0.01752071 -0.019989212 7.2 Microsatelite instability (MSI) Microsatelite instability (MSI) is the condition of genetic hypermutability (predisposition to mutation) that results from impaired DNA mismatch repair (MMR). Previous study shows that the MSI is highly associated with tumor mutation burden and closly related to immunothrapy response. Many tools MANTIS, MSIsensor, mSINGS, MSIsensor-pro are available to calcualte MSI score form RNA-seq data. in our RIMA pipeline, we applied MSIsensor2 to estimate MSI score, which allows tumor-only BAM input. #Run MSIsensor2 msisensor2 msi -M models_hg38 -t tumor.bam -o tumor ## Output of MSIsensor2 Total_Number_of_Sites Number_of_Somatic_Sites % 156 26 16.67 Example outputs of combined MSI: msi_res &lt;- read.table(&quot;msi_score.txt&quot;,header=FALSE,sep=&#39;\\t&#39;) print(msi_res) ## V1 V2 ## 1 SRR8281218 20.34 ## 2 SRR8281219 13.39 ## 3 SRR8281226 28.00 ## 4 SRR8281238 22.11 ## 5 SRR8281236 17.69 ## 6 SRR8281230 16.10 ## 7 SRR8281233 17.97 ## 8 SRR8281244 25.71 ## 9 SRR8281245 30.43 ## 10 SRR8281243 24.11 ## 11 SRR8281251 23.44 ## 12 SRR8281250 24.59 7.3 Response comparison analysis of biomarkers #read the metasheet metafile &lt;- &quot;metasheet.csv&quot; tide_res &lt;- &quot;TIDE_score.txt&quot; msi_res &lt;- &quot;msi_score.txt&quot; #load ploting function source(&quot;Tideploting.R&quot;) cmpr_biomk(msi_path = msi_res, tide_path = tide_res, meta_path = metafile, phenotype = &quot;Responder&quot;) Figure 7.1: Comparision of biomarkers between R and NR 7.4 Video demo "],["HLA.html", "Chapter 8 HLA Calling", " Chapter 8 HLA Calling "],["Neoantigen.html", "Chapter 9 Neoantigen Analysis 9.1 Somatic mutation 9.2 Neoantigen identification", " Chapter 9 Neoantigen Analysis 9.1 Somatic mutation 9.2 Neoantigen identification "],["fusion.html", "Chapter 10 Fusion 10.1 Fusion calling from CHIMERIC 10.2 Remove homolog 10.3 Comparison", " Chapter 10 Fusion 10.1 Fusion calling from CHIMERIC 10.2 Remove homolog 10.3 Comparison "],["microbiome.html", "Chapter 11 Microbiome", " Chapter 11 Microbiome With the advantage of high-throughput sequencing, we have the capabilities to explore the genomes of the tumor-bearing host and the various microbes that have the risk of infecting the host. It has been reported that the complicated dynamics of microbiota and hosts could influence the susceptibility to the infectious disease and affect the treatment approaches. Notably, gastrointestinal microbiota has been widely recognized for its role in cancer development and its association with the response and toxicity to cancer therapy89. Previous studies have investigated multiple ways in which gut microbiota influence anti-tumor immunity. For example, the modulation of microbial components helps to enhance T cell response and improve anti-PDL1 efficacy in melanoma patients91. The effect of microbial metabolites provides the energy source for neoplastic progression in colon cancer. Thus, it is essential to decipher microbiota components from the following perspectives: 1) the interactions between disease phenotypes and microbiota; the relationship between treatment efficacy and microbiota enrichment; 2) the involvement of microbiota in condition-specific metabolism pathways; 3) the application value of microbiota as a diagnostic biomarker. For decades, microbial phylogeny and taxonomy have relied on 16S rRNA sequencing and shot gun sequencing, which contains hypervariable regions as species-specific signatures for microbial identification. To perform computationally robust and effective ways for microbiota classification, researchers have developed reference-genome-based methods from high-throughput DNA or RNA sequencing, such as PathSeq and Centrifuge. PathSeq aligns non-host reads to pre-defined microbial organisms using BWA-MEM alignment, while Centrifuge builds a compressed index merged with unique genome sequences in advance. Although both methods achieve microbiota classification and abundance estimation based on users’ reference, Centrifuge outperforms in terms of the low memory and fast speed. Taken together, microbiota classification analysis is aimed to help understand the mechanisms of disease development, potentially providing new insights into therapeutic target discovery. ## Centrifuge ## Microial classfication from RNA-seq data. "]]
